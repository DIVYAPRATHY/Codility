1. Simple solution. The time complexity is too high. O(N*M)
class Solution {
    public int[] solution(int N, int[] A) {
        // write your code in Java SE 8
        int P [] = new int [N];
        for (int i=0;i<N;i++){
            P[i] = 0;    
        }
        for (int i=0;i<A.length;i++){
            if (A[i] == N+1){
               maxCounter(P);      
            }else{
               P[A[i]-1]++;    
            }    
        } 
        return P; 
    }
    
    public void maxCounter(int[] P){
        int maxNo = max(P);
        for (int i=0;i<P.length;i++){
            P[i] = maxNo;    
        }            
    }
    
    public int max(int[] P){
        int largest = P[0];
        for (int i=1;i<P.length;i++){
            if (P[i]>largest){
                largest = P[i];       
            }                
        }
        return largest;
    }
}

Score: 77%

2. Improve the previous method, time complexity is O(N+M). Keep the lastUpdate as the lasgest value in the last round.
class Solution {
    public int[] solution(int N, int[] A) {
        // write your code in Java SE 8
        int P [] = new int [N];
        int max = 0;
        int lastUpdate = 0;
        
        for (int i=0;i<A.length;i++){
            if (A[i] < N+1){
                if (P[A[i]-1] < lastUpdate){
                    P[A[i]-1] = lastUpdate + 1;          
                }else{
                    P[A[i]-1]++;    
                }
                max = Math.max(max, P[A[i]-1]);
            }else if (A[i] == N+1){
               lastUpdate = max;     
            }    
        }
        
        for(int i = 0; i < N; i++){
            if(P[i] < lastUpdate){
                P[i] = lastUpdate;
            }
        }   
        return P; 
    }

}
Score: 100%
